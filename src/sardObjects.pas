unit sardObjects;
{**
 *  This file is part of the "SARD"
 *
 * @license   The MIT License (MIT)
 *            Included in this distribution
 * @author    Zaher Dirkey <zaher at parmaja dot com>
 *}

{**
  Unit: Objects of run time generated by the scanner and raise in the memory until you free it,
  you can run it multiple time, also in the seperated thread

  The main object is TsoMain

  Object have Execute and Operate
  Some objects (like Section) have a Block, and some have one Statment
  Block have Statements
    Statement: haves Clauses
      Clause: Operator,Modifier,Object

  Declare: is define how to call that object, it have Defines and link to the object to execute and call
      Declare is a object of Caluse that call external (or internal) object, until now this object freed by declare and it is wrong :(

  Stack: have data for run time execute, you cant share value between thread or multiple execute for the main object
    So Stack have Local Variables, Shadow of object
  Shadow: it is mirror of object but have extra data about it that we can not save it in the original object,
    it is useful for multiexecute.

*}

{$IFDEF FPC}
{$mode delphi}
{$ENDIF}
{$H+}{$M+}

{
  Prefix guid:
    srd: global classes inherited from sard
    run: Runtime classes
    so: Sard objects, that created when compile the source
    op: Operators objects
}

{TODO:
  TtpType:    Type like integer, float, string, color or datetime, it is global, and limited

  TsoArray:   From the name, object have another objects, a list of objectd without execute it,
              it is save the result of statment come from the parser

* TsrdShadow: This object shadow of another object, he resposible of the memory storage like a varible
              When need to execute an object it will done by this shadow and insure it is exist before run
              Also we can make muliple shadow of one object when creating link to it, i mean creating another object based on first one
              Also it is made for dynamic scoping, we can access the value in it instead of local variable

  TrunEngine: Load file and compile it, also have debugger actions and log to console of to any plugin that provide that interface              Engine cache also compile files to use it again and it check the timestamp before recompile it

  TsrdAddons: It have any kind of addon, parsing, preprocessor, or debugger

  TmdModifier: It is like operator but with one side can be in the context before the identifier like + !x %x $x

}

interface

uses
  Classes, SysUtils,
  sardClasses, sardLexers;

const
  sSardVersion = '0.01';
  iSardVersion = 001;

type
  TNode = class;
  TDefines = class;
  TRunData = class;
  TRunEnv = class;

  TDebugInfo = class(TSardObject)
  end;

  { TClause }

  TClause = class(TSardObject)
  private
    FAnOperator: TSardOperator;
    FAnObject: TNode;
  protected
  public
    constructor Create(AOperator: TSardOperator; AObject: TNode);
    destructor Destroy; override;

    function Execute(Data: TRunData; Env: TRunEnv): Boolean;

    property AnOperator: TSardOperator read FAnOperator;
    property AnObject: TNode read FAnObject;
  end;

  { TStatement }

  TStatement = class(TSardObjects<TClause>)
  private
    FDebugInfo: TDebugInfo;
    FParent: TNode;
  public
    constructor Create(AParent: TNode);
    procedure Add(AOperator: TSardOperator; AObject: TNode);
    procedure Execute(Data: TRunData; Env: TRunEnv);
    property Parent: TNode read FParent;
    property DebugInfo: TDebugInfo read FDebugInfo; //<-- Null until we compiled it with Debug Info
  end;

  { TStatements }

  TStatements = class(TSardObjects<TStatement>)
  private
    FParent: TNode;
  public
    constructor Create(AParent: TNode); virtual;
    function Add: TStatement;
    procedure Propose;
    function Execute(Data: TRunData; Env: TRunEnv): Boolean;
    property Parent: TNode read FParent;
  end;

  { TNode }

  TNode = class abstract(TSardNamedObject)
  private
    FID: Integer;
    FParent: TNode;
    FRefCount: Integer;
    function GetAsBool: Bool;
    function GetAsInteger: Integer;
    function GetAsNumber: Number;
    function GetAsText: Text;
    procedure SetParent(AValue: TNode);
  protected
    procedure SetName(AValue: string); override;
  public
    function ToBool(out outValue: Boolean): Boolean;
    function ToText(out outValue: Text): Boolean;
    function ToNumber(out outValue: Number): Boolean;
    function ToInteger(out outValue: Integer): Boolean;

    property AsBool: Bool read GetAsBool;
    property AsText: Text read GetAsText;
    property AsNumber: Number read GetAsNumber;
    property AsInteger: Integer read GetAsInteger;

    procedure Assign(AFromObject: TNode); virtual;
    function Clone(WithValues: Boolean = True): TNode;
  protected
    function DoOperate(AObject: TNode; AOperator: TSardOperator): Boolean; virtual;
    procedure DoExecute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator; var Done: Boolean); virtual; abstract;
    procedure BeforeExecute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator); virtual;
    procedure AfterExecute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator); virtual;
  public
    constructor Create;
    function Operate(AObject: TNode; AOperator: TSardOperator): Boolean;
    function Execute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator; Defines: TDefines = nil; Arguments: TStatements = nil; Blocks: TStatements = nil): Boolean;
    property Parent: TNode read FParent write SetParent;
    property ID: Integer read FID;
  end;

  {TRefObject = class(TSardObject)
  end;}

  { TDefine }

  TDefine = class(TSardNamedObject)
  private
    FDefType: string;
  public
    constructor Create(ADefName: string; ADefType: string);
    property DefType:string read FDefType write FDefType;
  end;

  { TDefineItems }

  TDefineItems = class(TSardNamedObjects<TDefine>)
  public
    procedure Add(ADefName: string; ADefType: string);
  end;

  { TDefines }

  TDefines = class(TSardObject)
  private
    FParameters: TDefineItems;
    FBlock: TDefineItems;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Execute(Data: TRunData; Env: TRunEnv; Arguments: TStatements = nil);
    property Parameters: TDefineItems read FParameters;
    property Block: TDefineItems read FBlock;
  end;

{*
  Variables
*}

  TRunVarKind = (rkLocal, rkArgument);
  TRunVarKinds = set of TRunVarKind;

  { TSardRunValue }

  { TRunValue }

  TRunValue = class(TSardNamedObject)
  private
    FValue: TNode; //RefObject maybe IObject_Node
    FRunKind: TRunVarKinds;
    procedure SetValue(AValue: TNode);
  public
    constructor Create; overload;
    constructor Create(AName: string; ARunKind: TRunVarKinds); overload;
    procedure Clear;
    property RunKind: TRunVarKinds read FRunKind;
    property Value: TNode read FValue write SetValue;
  end;

  { TRunVariables }

  TRunVariables = class(TSardNamedObjects<TRunValue>)
  public
    function Register(AName: string; ARunKind: TRunVarKinds): TRunValue;
  end;

  { TRunResult }

  TRunResult = class(TSardObject)
  private
  public
    Result: TRunValue;
    constructor Create;
  end;

  { TRunResults }

  TRunResults = class(TSardStack<TRunResult>)
  public
    procedure Push; overload;
  end;

  { TDeclare_Node }

  TDeclare_Node = class(TNode)
  private
    FDefines: TDefines;
  public
    //executeObject will execute in a context of statement if it is not null,
    ExecuteObject: TNode;
    ResultType: string;
    procedure Created; override;
    destructor Destroy; override;
    procedure DoExecute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator; var Done: Boolean); override;
    property Defines: TDefines read FDefines;
  end;
{
  *   Declare object to take it ref into variable
  *   used by Declare_Node
  //Is that a Scope!!!, idk!
}

  { TRunData }

  TRunData = class(TSardObjects<TRunData>)
  private
    FAnObject: TDeclare_Node;
    FName: string;
    FParent: TRunData;
  public
    constructor Create(AParent: TRunData);

    function Find(const AName: string): TRunData;
    function FindObject(AObject: TNode): TRunData;
    function Declare(AObject: TDeclare_Node): TRunData;
    function FindDeclare(AName: string): TRunData;

    function Execute(Env: TRunEnv; AOperator: TSardOperator; Arguments: TStatements = nil; Blocks: TStatements = nil): Boolean;

    property Name: string read FName;
    property AnObject: TDeclare_Node read FAnObject;
    property Parent: TRunData read FParent;
  end;

{
  *  Local is stack of flow control
  *  Not a scope
  *
}

  { TRunStackItem }

  TRunStackItem = class(TSardObject)
  public
    Variables: TRunVariables;
    constructor Create;
    destructor Destroy; override;
  end;

  { TRunStack }

  TRunStack = Class(TSardStack<TRunStackItem>)
  public
    procedure Push; overload;
  end;

  { TRunEnv }

  TRunEnv = class(TSardObject)
  private
    FResults: TRunResults;
    FRoot: TRunData;
    FStack: TRunStack;
  public
    constructor Create;
    destructor Destroy; override;

    property Results: TRunResults read FResults;
    property Stack: TRunStack read FStack;
    property Root: TRunData read FRoot;
  end;

implementation

{ TRunStack }

procedure TRunStack.Push;
begin
  inherited Push(TRunStackItem.Create);
end;

{ TRunResults }

procedure TRunResults.Push;
begin
  inherited Push(TRunResult.Create);
end;

{ TRunEnv }

constructor TRunEnv.Create;
begin
  inherited Create;
  FResults := TRunResults.Create;
  FRoot := TRunData.Create(nil);
  FStack := TRunStack.Create;
end;

destructor TRunEnv.Destroy;
begin
  FreeAndNil(FResults);
  FreeAndNil(FRoot);
  FreeAndNil(FStack);
  inherited;
end;

{ TRunStackItem }

constructor TRunStackItem.Create;
begin
  inherited;
  Variables := TRunVariables.Create;
end;

destructor TRunStackItem.Destroy;
begin
  FreeAndNil(Variables);
  inherited;
end;

{ TDeclare_Node }

procedure TDeclare_Node.Created;
begin
  inherited;
  FDefines := TDefines.Create;
end;

destructor TDeclare_Node.Destroy;
begin
  FreeAndNil(FDefines);
  inherited;
end;

procedure TDeclare_Node.DoExecute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator; var Done: Boolean);
begin
  Data.Declare(Self);
end;

{ TRunData }

constructor TRunData.Create(AParent: TRunData);
begin
  inherited Create;
  FParent := AParent;
end;

function TRunData.Find(const AName: string): TRunData;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to Count - 1 do
  begin
    if SameText(Items[i].Name, AName) then
    begin
      Result := Items[i];
      break;
    end;
  end;
end;

function TRunData.FindObject(AObject: TNode): TRunData;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to Count - 1 do
  begin
    if Items[i].AnObject = AObject then
    begin
      Result := Items[i];
      break;
    end;
  end;
end;

function TRunData.Declare(AObject: TDeclare_Node): TRunData;
begin
  if AObject = nil then
    RaiseError('Can not register null in data');
  Result := FindObject(AObject);
  if Result = nil then
  begin
    Result := TRunData.Create(Self);
    Result.FName := AnObject.Name;
    Result.FAnObject := AnObject;
  end;
  Add(Result);//TODO BUG maybe into if
end;

function TRunData.FindDeclare(AName: string): TRunData;
begin
  Result := Find(AName);
  if (Result <> nil) and (Parent <> nil) then
  Result := Parent.FindDeclare(AName);

end;

function TRunData.Execute(Env: TRunEnv; AOperator: TSardOperator; Arguments: TStatements; Blocks: TStatements): Boolean;
begin
  if AnObject = nil then
    RaiseError('Object of declaration is not set!')
  else if AnObject.ExecuteObject = nil then
  begin
    RaiseError('ExecuteObject of declaration is not set!');
    Result := AnObject.ExecuteObject.Execute(Self, Env, AOperator, AnObject.Defines, Arguments, Blocks);
  end;
end;

{ TRunResult }

constructor TRunResult.Create;
begin
  inherited Create;
  Result := TRunValue.Create;
end;

{ TRunValue }

procedure TRunValue.SetValue(AValue: TNode);
begin
  if FValue =AValue then Exit;
  FValue :=AValue;
end;

constructor TRunValue.Create;
begin
  inherited Create;
end;

constructor TRunValue.Create(AName: string; ARunKind: TRunVarKinds);
begin
  inherited Create;
  Name := AName;
  FRunKind := ARunKind;
end;

procedure TRunValue.Clear;
begin
  Value := nil;
end;

{ TRunVariables }

function TRunVariables.Register(AName: string; ARunKind: TRunVarKinds): TRunValue;
begin
  Result := Find(AName);
  if Result = nil then
  begin
    Result := TRunValue.Create(AName, ARunKind);
    inherited Add(Result);
  end;
end;

{ TDefines }

constructor TDefines.Create;
begin
  inherited Create;
  FParameters := TDefineItems.Create;
  FBlock := TDefineItems.Create;
end;

destructor TDefines.Destroy;
begin
  FreeAndNil(FParameters);
  FreeAndNil(FBlock);
  inherited Destroy;
end;

{ TDefineItems }

procedure TDefineItems.Add(ADefName: string; ADefType: string);
begin
  inherited Add(TDefine.Create(ADefName, ADefType));
end;

{ TDefine }

constructor TDefine.Create(ADefName: string; ADefType: string);
begin
  inherited Create;
  Name := ADefName;
  FDefType := ADefType;
end;

procedure TDefines.Execute(Data: TRunData; Env: TRunEnv; Arguments: TStatements);
var
  i: Integer;
  p: TDefine;
  v: TRunValue;
begin
  if Arguments <> nil then
  begin //TODO we need to check if it is a block?
    i := 0;
    while i < Parameters.Count do
    begin
      Env.Results.Push;
      Arguments[i].Execute(Data, Env);
      if i < Arguments.Count then
      begin
        p := Parameters[i];
        v := Env.Stack.Current.Variables.Register(p.name, [rkLocal, rkArgument]); //TODO but must find it locally
        v.Value := Env.Results.Current.Result.Value;
      end;
      Env.Results.Pop;
      Inc(i);
    end;
  end;
end;

{ TStatements }

constructor TStatements.Create(AParent: TNode);
begin
  inherited Create;
  FParent := AParent;
end;

function TStatements.Add: TStatement;
begin
  Result := TStatement.Create(Parent);
  inherited Add(Result);
end;

procedure TStatements.Propose;
begin
  if Count = 0 then
    Add;
end;

function TStatements.Execute(Data: TRunData; Env: TRunEnv): Boolean;
var
  itm: TClause;
begin
  if Count = 0 then
    Result := False
  else
  begin
    for itm in Self do
    begin
      //* each statment have a result
      Env.Results.Push;
      itm.Execute(Data, Env);
      Env.Results.Pop;
      //* if the current statement assigned to parent or variable result "Reference" here have this object, or we will throw the result
    end;
    Result := True;
  end;
end;

{ TStatement }

procedure TStatement.Add(AOperator: TSardOperator; AObject: TNode);
begin
  if (AObject.Parent <> nil) then
    RaiseError('You can not add object to another parent!');
  AObject.FParent := Parent;
  inherited Add(TClause.Create(AOperator, AObject));
end;

procedure TStatement.Execute(Data: TRunData; Env: TRunEnv);
var
  itm: TClause;
begin
  //https://en.wikipedia.org/wiki/Shunting-yard_algorithm
  //:= "Result is " + 10 + 10 ;
  for itm in Self do
  begin
    itm.Execute(Data, Env);
  end;
end;

constructor TStatement.Create(AParent: TNode);
begin
  inherited Create;
  FParent := AParent;
end;

{ TNode }

function TNode.GetAsBool: Bool;
begin
  if not ToBool(Result) then
    Result := false;
end;

function TNode.GetAsInteger: Integer;
begin
  if not ToInteger(Result) then
    Result := 0;
end;

function TNode.GetAsNumber: Number;
begin
  if not ToNumber(Result) then
    Result := 0;
end;

function TNode.GetAsText: Text;
begin
  if not ToText(Result) then
    Result := '';
end;

procedure TNode.SetParent(AValue: TNode);
begin
  if (FParent <> nil) then
    RaiseError('Already have a parent');
  FParent := AValue;
end;

procedure TNode.SetName(AValue: string);
begin
  if Name <> '' then
    RaiseError('Already Named!');
  inherited;
end;

{constructor TNode.Create(AParent: TNode; AName: string);
begin
  inherited Create;
  Name := AName;
  FParent := AParent;
end;}

function TNode.Operate(AObject: TNode; AOperator: TSardOperator): Boolean;
begin
  if AOperator = nil then
    Result := false
  else
    Result := AObject.Operate(AObject, AOperator);
end;

function TNode.Execute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator; Defines: TDefines; Arguments: TStatements; Blocks: TStatements): Boolean;
begin
  Result := false;
  BeforeExecute(Data, Env, AOperator);
  if (Defines <> nil) then
      Defines.Execute(Data, Env, Arguments);
  DoExecute(Data, Env, AOperator, Result);
  AfterExecute(Data, Env, AOperator);
end;

function TNode.ToBool(out outValue: Boolean): Boolean;
begin
  Result := False;
end;

function TNode.ToText(out outValue: Text): Boolean;
begin
  Result := False;
end;

function TNode.ToNumber(out outValue: Number): Boolean;
begin
  Result := False;
end;

function TNode.ToInteger(out outValue: Integer): Boolean;
begin
  Result := False;
end;

procedure TNode.Assign(AFromObject: TNode);
begin
  //Nothing
end;

function TNode.Clone(WithValues: Boolean): TNode;
begin
  //TODO, here we want to check if subclass have a default ctor
  Result := TNode(Self.ClassType).Create;
  Result.FParent := Parent;
  if WithValues then
    Result.Assign(Self);
end;

function TNode.DoOperate(AObject: TNode; AOperator: TSardOperator): Boolean;
begin
  Result := False;
end;

procedure TNode.BeforeExecute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator);
begin
  if Data = nil then
    RaiseError('Data is needed!');
end;

procedure TNode.AfterExecute(Data: TRunData; Env: TRunEnv; AOperator: TSardOperator);
begin

end;

constructor TNode.Create;
begin
  inherited Create;
end;

{ TClause }

constructor TClause.Create(AOperator: TSardOperator; AObject: TNode);
begin
  inherited Create;
  FAnOperator:= AOperator;
  FAnObject:= AObject;
end;

destructor TClause.Destroy;
begin
  FreeAndNil(FAnObject);
  inherited;
end;

function TClause.Execute(Data: TRunData; Env: TRunEnv): Boolean;
begin
  if FAnObject = nil then
    RaiseError('Object not set!');
  Result := FAnObject.Execute(Data, Env, AnOperator);
end;

end.
